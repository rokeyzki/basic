# 前端 base

## 类别
* es6：前端的相关Demo（核心：ECMAScript，推荐：Underscore 1.7）
    * 语法
    * 路由
* api：后端的相关Demo（核心：RESTful API，推荐：LeanCloud）
    * 权限
    * 数据
* d3: 数据可视化的相关Demo
    * SVG
    * GIS
* jquery：前台制作的相关Demo（核心：IE8，推荐：jQuery 1.12）
    * 布局
    * 特效
* react：后台制作的相关Demo（核心：React，推荐：redux-router、antD）
    * 工程
    * 组件
* redux：状态的相关Demo（核心：Redux，推荐：redux-promise）
    * 同步
    * 异步
* nodejs: 工具制作的相关Demo（核心：Node.js） 
    * cli 命令行工具
    * npm 模块包管理

## TODO
* 算法：blog 整理
* 设计模式：极客学院视频教程
* js 基础：blog 整理
* css 布局：blog 整理
* http 协议：状态码

# JavaScript代码

## 代码编译阶段/CP（编译器）

* 词法语法分析
* 可执行代码生成
* 作用域/Scope规则确定
    * 全局作用域/GS
    * 函数作用域/FS
    * 块级作用域/BS（let声明的变量）
    * eval

## 代码执行阶段/EP（脚本引擎）

* 执行上下文/EC栈处理（脚本引擎以【栈/stack】的方式来处理执行上下文）
    * 执行上下文/EC创建阶段
        * 创建变量对象/VO（脚本引擎以【堆/heap】的方式来处理变量对象）
            * 创建arguments对象
            * 检查函数声明，创建属性（检查当前上下文的函数声明，也就是使用function关键字声明的函数，不包括变量函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。）
            * 检查变量声明，创建属性（检查当前上下文的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果当前上下文的该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。）
        * 建立作用域链/SC（脚本引擎以【栈/stack】的方式来处理作用域链）
        * 确定this指向
            * 直接调用的函数（函数中的this指向undefined，在非严格模式下，this指向全局对象）
            * 全局环境的对象（属性中的this指向全局对象）
            * 函数环境的对象（属性中的this指向undefined，在非严格模式下，this指向全局对象）
            * 对象方法的函数（函数中的this指向所属对象）
            * 构造函数与原型方法上的this（函数中的this指向实例对象）
            * 使用call，apply显性指定this（函数中的this指向参数对象）
    * 执行上下文/EC执行阶段
        * 变量对象/VO转变为了活动对象/AO（未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作）
        * 变量赋值
        * 执行代码
* 垃圾回收（JS的内存生命周期）
    * 分配你所需要的内存
    * 使用分配到的内存（读、写）
    * 不需要时将其释放、归还

## 数据类型

* 基础数据类型
* 引用数据类型

## 待理解

* Scope
* VO
* SC
* this

## 严格模式
* ES6 默认启用严格模式
* Node.js 默认启用严格模式
